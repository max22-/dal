( Macros )
%BREAKPOINT { #01 .System/debug DEO }
( Types )
%LIST { #00 }
%CHARACTER { #01 }
%LEFT_BRACKET { #02 }
%RIGHT_BRACKET { #03 }
%INTEGER { #04 }
%WORD { #05 }

|00 @System     &vector $2 &wst      $1 &rst    $1 &eaddr  $2 &ecode  $1 &pad     $1 &r       $2 &g      $2 &b     $2 &debug  $1 &halt $1
|10 @Console    &vector $2 &read     $1 &pad    $5 &write  $1 &error  $1


%MAX_TREE_SIZE { $1400 } ( -- 1024 nodes of 5 bytes each )

|00 @node &data $2 &type $1 &parent $2 &node-length
|00 @tree &node-count $2 &nodes

|0100

    ;program print-string
    ;program ;tree1 string-to-tree
    ;tree1 print-tree
    BRK

@string-to-tree ( str* tree* -- )
    STH2k reset-tree
    #0000 LIST #0000 STH2kr add-node
    &loop LDAk DUP #00 EQU ?&end
    #00 SWP ( transform char into short ) CHARACTER #0000 STH2kr add-node
    INC2 !&loop
    &end
    POP2
    POP2r
    JMP2r

@reset-tree ( tree* -- )
    #0000 SWP2 ;tree/node-count ADD2 STA2
    JMP2r

@add-node ( data* type parent* tree* -- )
    STH2k
    DUP2 get-node-count get-node
    ( data* type parent* node-address -- )
    STH2k
    ;node/parent ADD2 STA2
    STH2kr
    ;node/type ADD2 STA
    STH2kr
    ;node/data ADD2 STA2
    POP2r
    STH2kr get-node-count INC2 STH2r ;tree/node-count ADD2 STA2
    JMP2r

@get-node ( tree* node-id* -- node-address* )
    ;node/node-length MUL2 ;tree/nodes ADD2 ADD2
    JMP2r

@get-node-data ( tree* node-id* -- node-data* )
    get-node ;node/data ADD2 LDA2
    JMP2r

@get-node-type ( tree* node-id* -- node-type )
    get-node ;node/type ADD2 LDA
    JMP2r

@get-node-parent ( tree* node-id* -- node-parent* )
    get-node ;node/data ADD2 LDA2
    JMP2r

@get-node-count ( tree* -- node-count* )
    ;tree/node-count ADD2 LDA2
    JMP2r

@get-node-depth ( *tree *node-id -- depth* )
    SWP2 ,&tree STR2
    #0000 ,&counter STR2
    
    ( node-id* -- )
    &loop
    DUP2 LIT2 &tree $2 SWP2 get-node-parent
    ( old-node-id* node-id* -- )
    DUP2 ROT2 EQU2 ?&end
    ,&counter LDR2 INC2 ,&counter STR2
    &end
    POP2
    ,&counter LDR2
    JMP2r
    &counter 0000

@indent ( depth* -- )
    &loop
    DUP2 #0000 EQU2 ?&end
    ;&indent-str print-string
    #ffff ADD2
    !&loop
    &end
    POP2
    JMP2r
    &indent-str 20 20 20 20 $1
    

@print-tree ( tree* -- )
    STH2k
    get-node-count DUP2 print-short-decimal ;&nodes-msg print-string
    ( node-count* -- )
    ,&node-count STR2
    #0000
    &loop
    DUP2 LIT2 &node-count $2 EQU2 ?&end
    STH2kr OVR2 get-node-depth indent
    STH2kr OVR2 print-node #0a #18 DEO
    INC2 !&loop
    &end
    POP2
    POP2r
    JMP2r
    &nodes-msg 20 "nodes 0a $1

@print-node ( tree* node-number* -- )
    ( BREAKPOINT )
    STH2 STH2 STH2kr SWP2r STH2kr SWP2r ( make a copy of the arguments on the return stack )
    get-node-type

    DUP LIST NEQ ?&not-list 
    ;list-str print-string
    !&end JMP
    &not-list

    DUP CHARACTER NEQ ?&not-char
    STH2kr SWP2r STH2kr SWP2r ( get the arguments from the return stack )
    get-node-data SWP POP .Console/write DEO
    &not-char

    &end
    POP ( pop node type )
    POP2r POP2r ( pop the stashed tree* and node-number* arguments )
    JMP2r

@program
    "[dup 20 "0 20 "= 20 "[1 20 "drop] 20 "[dup 20 "1 20 "- 20 "fac 20 "*] 20 "ifte] 20 "' 20 "fac 20 "def $1
@list-str "LIST $1

@tree1 MAX_TREE_SIZE

~helpers.tal